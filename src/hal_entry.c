#include "hal_data.h"
#include "SEGGER_RTT/SEGGER_RTT.h"
#include "utils.h"

FSP_CPP_HEADER
void R_BSP_WarmStart(bsp_warm_start_event_t event);
FSP_CPP_FOOTER


/**
 * Selected low power mode:
 * LPM_SLEEP defined:   sleep
 * LPM_SLEEP undefined: software standby
 */
#define LPM_SLEEP

/**
 * Timer for waking up from LPM:
 * LPM_TIMER_AGT1 defined:   AGT1
 * LPM_TIMER_AGT1 undefined: AGT3
 */
#define LPM_TIMER_AGT1


void timer_callback(timer_callback_args_t *p_args) {
    (void)p_args;
}


/*******************************************************************************************************************//**
 * main() is generated by the RA Configuration editor and is used to generate threads if an RTOS is used.  This function
 * is called by main() when no RTOS is used.
 **********************************************************************************************************************/
void hal_entry(void) {
    fsp_err_t fsp_ret;

#ifdef LPM_SLEEP
    lpm_ctrl_t * const lpm_ctrl = &g_lpm_sleep_ctrl;
    const lpm_cfg_t * const lpm_cfg = &g_lpm_sleep_cfg;
#else
    lpm_ctrl_t * const lpm_ctrl = &g_lpm_sw_standby_ctrl;
    const lpm_cfg_t * const lpm_cfg = &g_lpm_sw_standby_cfg;
#endif

#ifdef LPM_TIMER_AGT1
    timer_ctrl_t * const timer_ctrl = &g_timer1_ctrl;
    const timer_cfg_t * const timer_cfg = &g_timer1_cfg;
#else
    timer_ctrl_t * const timer_ctrl = &g_timer3_ctrl;
    const timer_cfg_t * const timer_cfg = &g_timer3_cfg;
#endif

    SEGGER_RTT_printf(0, "Application start \r\n");

    set_leds(LED_BLUE, 1);
    R_BSP_SoftwareDelay(10, BSP_DELAY_UNITS_MILLISECONDS);
    set_leds(LED_BLUE, 0);
    R_BSP_SoftwareDelay(50, BSP_DELAY_UNITS_MILLISECONDS);


    fsp_ret = R_LPM_Open(lpm_ctrl, lpm_cfg);
    RED_ON_ERROR(fsp_ret, "R_LPM_Open");

    fsp_ret = R_AGT_Open(timer_ctrl, timer_cfg);
    RED_ON_ERROR(fsp_ret, "R_AGT_Open");

    fsp_ret = R_AGT_Start(timer_ctrl);
    RED_ON_ERROR(fsp_ret, "R_AGT_Start");

    set_leds(LED_BLUE, 1);

    fsp_ret = R_LPM_LowPowerModeEnter(lpm_ctrl);
    RED_ON_ERROR(fsp_ret, "R_LPM_LowPowerModeEnter");

    set_leds(LED_GREEN, 1);

    SEGGER_RTT_printf(0, "Application finished \r\n");

    while(1);

#if BSP_TZ_SECURE_BUILD
    /* Enter non-secure code */
    R_BSP_NonSecureEnter();
#endif
}

/*******************************************************************************************************************//**
 * This function is called at various points during the startup process.  This implementation uses the event that is
 * called right before main() to set up the pins.
 *
 * @param[in]  event    Where at in the start up process the code is currently at
 **********************************************************************************************************************/
void R_BSP_WarmStart(bsp_warm_start_event_t event) {
	if (BSP_WARM_START_RESET == event) {
#if BSP_FEATURE_FLASH_LP_VERSION != 0

        /* Enable reading from data flash. */
        R_FACI_LP->DFLCTL = 1U;

        /* Would normally have to wait tDSTOP(6us) for data flash recovery. Placing the enable here, before clock and
         * C runtime initialization, should negate the need for a delay since the initialization will typically take more than 6us. */
#endif
	}

	if (BSP_WARM_START_POST_C == event) {
		/* C runtime environment and system clocks are setup. */

		/* Configure pins. */
		R_IOPORT_Open(&g_ioport_ctrl, &g_bsp_pin_cfg);
	}
}

#if BSP_TZ_SECURE_BUILD

BSP_CMSE_NONSECURE_ENTRY void template_nonsecure_callable ();

/* Trustzone Secure Projects require at least one nonsecure callable function in order to build (Remove this if it is not required to build). */
BSP_CMSE_NONSECURE_ENTRY void template_nonsecure_callable ()
{

}
#endif
